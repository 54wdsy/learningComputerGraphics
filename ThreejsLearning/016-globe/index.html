<p>贪心块</p>
<style>
  body {
    margin: 0;
    padding: 0;
  }

  #container {
    position: fixed;
  }

</style>
<script src="../lib/three(105).js"></script>
<script id="vertexShader" type="x-shader/x-vertex">
  varying highp vec2 vUv;
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
uniform vec3 u_resolution;
uniform float u_time;
uniform sampler2D iChannel0;
varying highp vec2 vUv;

mat3 xrot(float angle) {
  mat3 m;
  m[0] = vec3(1.0, 0.0, 0.0);
  m[1] = vec3(0.0, cos(angle), -sin(angle));
  m[2] = vec3(0.0, sin(angle), cos(angle));
  return m;
}

mat3 yrot(float angle) {
  mat3 m;
  m[0] = vec3(cos(angle), 0.0, -sin(angle));
  m[1] = vec3(0.0, 1.0, 0.0);
  m[2] = vec3(sin(angle), 0.0, cos(angle));
  return m;
}

float intersectSphere(vec3 camera, vec3 ray, vec3 sphereOrigin, float sphereRadius) {
  float radiusSquared = sphereRadius * sphereRadius;
  float dt = dot(ray, sphereOrigin - camera);
  if (dt < 0.0) {
      return -1.0;
  }
  vec3 tmp = camera - sphereOrigin;
  tmp.x = dot(tmp, tmp);
  tmp.x = tmp.x - dt * dt;
  if (tmp.x >= radiusSquared) {
      return -1.0;
  }
  float distanceFromCamera = dt - sqrt(radiusSquared - tmp.x);
  return distanceFromCamera;
}

vec4 render(vec2 uv, float time) {
  // vec3 lightPosition = vec3(0.0, 0.0, -25.0);

  uv = uv * 2.0;
  uv.y -= 1.0;
  uv.x -= 1.0;
  // uv.x -= (1.0 / (u_resolution.y / u_resolution.x));

  vec3 pixelPosition = vec3(uv.x/5., uv.y/5., -9);
  vec3 cameraPosition = vec3(0.0, 0.0, -10.0);
  vec3 ray = pixelPosition - cameraPosition;  // Generate a ray
  ray = normalize(ray);

  // ray = ray * xrot(time * 0.3) * yrot(time * 0.3);
  // cameraPosition = cameraPosition * xrot(time * 0.3) * yrot(time * 0.3);
  // lightPosition = cameraPosition;

  vec3 spherePosition = vec3(0.0, 0.0, 0.0);
  float sphereRadius = 1.4;
  float distance = intersectSphere(cameraPosition, ray, spherePosition, sphereRadius);
  if (distance > 0.0) {
    vec3 pointOfIntersection = cameraPosition + ray * distance;
    vec3 normal = normalize(pointOfIntersection - spherePosition);

     float u =  atan(normal.z, normal.x) / (3.1415926 * 2.0);
     float v =  asin(normal.y) / -3.1415926;
    //float u = atan(0., uv.x)/(3.1415926 * 2.0);
    //float v = asin(uv.y)/(3.1415926 * 1.0);
    // 亮度
    // float brightness = dot(normalize(lightPosition - spherePosition), normal);
    // if (brightness < 0.0) {
    //     brightness = 0.0;
    // }
    vec4 outputColor = texture2D(iChannel0, vec2(fract(u), fract(v)));

    float x = u * 48.0;
    float y = v * 48.0;
    if (fract(x) < 0.1 || fract(y) < 0.1) {
      outputColor *= 0.5;
    }
    return outputColor * 1.0;
  }
  else {
    return vec4(0.0, 0.0, 0.0, 1.0);
  }
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
  vec2 uv = fragCoord.xy / u_resolution.xy;
  uv.x /= u_resolution.y / u_resolution.x;
  fragColor = render(uv, u_time);
}

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
  // gl_FragColor = texture2D(iChannel0, vUv);
}
</script>
<div id="container"></div>

<script>
  var container;
  var camera, scene, renderer;
  var uniforms;

  function loadTexture(url) {
    return new Promise((resolve, reject) => {
      const loader = new THREE.TextureLoader();
      loader.load(url, (res) => {
        resolve(res)
      });
    })
  }

  async function init() {
    container = document.getElementById('container');
    camera = new THREE.Camera();
    camera.position.z = 1;
    scene = new THREE.Scene();
    window.scene = scene
    scene.add(camera)
    const texture = await loadTexture("./uv.png")
    texture.minFilter = THREE.NearestFilter;
    texture.magFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    const plane = new THREE.PlaneBufferGeometry(2, 2);
    uniforms = {
      u_time: { type: "f", value: 0 },
      u_resolution: { type: "v3", value: new THREE.Vector3() },
      u_mouse: { type: "v2", value: new THREE.Vector2() },
      iChannel0: { type: "t", value: texture }
    };

    var material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent
    });

    var mesh = new THREE.Mesh(plane, material);
    scene.add(mesh);

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.autoClearColor = false;
    container.appendChild(renderer.domElement);

    onWindowResize();
    window.addEventListener('resize', onWindowResize, false);

    document.onmousemove = function (e) {
      uniforms.u_mouse.value.x = e.pageX
      uniforms.u_mouse.value.y = e.pageY
    }
    animate();
  }

  function onWindowResize(event) {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.u_resolution.value.x = renderer.domElement.width;
    uniforms.u_resolution.value.y = renderer.domElement.height;
    uniforms.u_resolution.value.z = 1;
    // console.error(uniforms.u_resolution)
  }

  function animate() {
    requestAnimationFrame(animate);
    render();
  }

  function render() {
    uniforms.u_time.value += 0.05;
    renderer.render(scene, camera);
  }



  init();
  //
</script>
